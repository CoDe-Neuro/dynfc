{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#dynfc-code-neuros-dynamic-functional-connectivity-tools","title":"dynFC: CoDe-Neuro's Dynamic Functional Connectivity Tools","text":"<p>This is the documentation page for 'dynfc', a Python module consisting of a set of tools developed to infer connectivity from fMRI (BOLD) signals. The module contains both phase-lock and correlation (+ cofluctuation) methods. Please be aware that this is still a develepment version and so may contain bugs and limited functionalities.</p> <p>If you have any questions or suggestions, please open an issue. </p> <p>Please do not hesitate to suggest improvements to this module.</p>"},{"location":"#citation","title":"Citation","text":"<p>:warning: Please, use the following article for reference:</p> <p>Lucas G. S. Fran\u00e7a, Judit Ciarrusta, Oliver Gale-Grant, Sunniva Fenn-Moltu, Sean Fitzgibbon, Andrew Chew, Shona Falconer, Ralica Dimitrova, Lucilio Cordero-Grande, Anthony N Price, Emer Hughes, Jonathan O\u2019Muircheartaigh, Eugene Duff, Jetro J Tuulari, Gustavo Deco, Serena J Counsell, Joseph V Hajnal, Chiara Nosarti, Tomoki Arichi, A David Edwards, Grainne McAlonan, Dafnis Batalle. bioRxiv 2022.11.16.516610; doi: https://doi.org/10.1101/2022.11.16.516610</p>"},{"location":"#built-on","title":"Built on","text":"Numpy Scipy"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>setup.py    \ndynfc/\n    __init__.py\n    ...       # Python script files  \ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\ntests/        # Tests folder\n    __init__.py\n    test_functions.py\n</code></pre>"},{"location":"#funding","title":"Funding","text":"<p>This project is funded by a Wellcome Trust Seed Award in Science [217316/Z/19/Z].</p>"},{"location":"butter_bandpass_filter-reference/","title":"Butterworth filter","text":""},{"location":"butter_bandpass_filter-reference/#dynfc.butter_bandpass_filter.butter_bandpass_filter","title":"<code>butter_bandpass_filter(x, flp, fhi, delt, order)</code>","text":"<p>Butterworth filter design.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array_like</code> <p>Signal to be filtered.</p> required <code>flp</code> <code>float</code> <p>Low-pass frequency.</p> required <code>fhi</code> <code>float</code> <p>High-pass frequency.</p> required <code>delt</code> <code>int</code> <p>Sampling interval.</p> required <code>order</code> <code>int</code> <p>Filter order.</p> required <p>Returns:</p> Name Type Description <code>double</code> <p>Filtered signal.</p> Source code in <code>dynfc/butter_bandpass_filter.py</code> <pre><code>def butter_bandpass_filter(x, flp, fhi, delt, order):\n\"\"\"Butterworth filter design.\n\n    Args:\n        x (array_like): Signal to be filtered.\n        flp (float): Low-pass frequency.\n        fhi (float): High-pass frequency.\n        delt (int): Sampling interval.\n        order (int): Filter order.\n\n    Returns:\n        double: Filtered signal.\n    \"\"\"\n\n    b, a = butter_design(flp, fhi, delt, order)\n    y = filtfilt(b, a, x)\n\n    return y\n</code></pre>"},{"location":"butter_design-reference/","title":"Butterworth filter design","text":""},{"location":"butter_design-reference/#dynfc.butter_design.butter_design","title":"<code>butter_design(flp, fhi, delt, order)</code>","text":"<p>Butterworth filter design.</p> <p>Parameters:</p> Name Type Description Default <code>flp</code> <code>float</code> <p>Low-pass frequency.</p> required <code>fhi</code> <code>float</code> <p>High-pass frequency.</p> required <code>delt</code> <code>int</code> <p>Sampling interval.</p> required <code>order</code> <code>int</code> <p>Filter order.</p> required <p>Returns:</p> Name Type Description <code>double</code> <p>Filter design.</p> Source code in <code>dynfc/butter_design.py</code> <pre><code>def butter_design(flp, fhi, delt, order):\n\"\"\"Butterworth filter design.\n\n    Args:\n        flp (float): Low-pass frequency.\n        fhi (float): High-pass frequency.\n        delt (int): Sampling interval.\n        order (int): Filter order.\n\n    Returns:\n        double: Filter design.\n    \"\"\"\n\n    fnq = 1 / (2 * delt)       # Nyquist frequency\n    low = flp / fnq\n    high = fhi / fnq\n    b, a = butter(order, [low, high], btype='bandpass')\n    return b, a\n</code></pre>"},{"location":"cc-reference/","title":"Correlation of correlarion","text":""},{"location":"cc-reference/#dynfc.cc.cc","title":"<code>cc(series, size, k=1)</code>","text":"<p>Run cofluctuation analysis for BOLD signal.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>double</code> <p>BOLD signal array for all parcels/voxels in the format [N, Tmax].</p> required <code>size</code> <code>int</code> <p>Size of window.</p> required <code>k</code> <code>int</code> <p>Standard value k = 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>double</code> <p>Correlation of correlation matrix for all timepoints [timepoints/size, timepoints/size].</p>"},{"location":"cc-reference/#dynfc.cc.cc--references","title":"References","text":"<p>.. [1]  Hansen, E. C. A. et al. (2015) \u2018Functional connectivity dynamics:  Modeling the switching behavior of the resting state\u2019, NeuroImage.  105, pp. 525\u2013535.  doi: 10.1016/j.neuroimage.2014.11.001.</p> Source code in <code>dynfc/cc.py</code> <pre><code>def cc(series, size, k = 1):\n\"\"\"Run cofluctuation analysis for BOLD signal.\n\n    Args:\n        series (double): BOLD signal array for all parcels/voxels in the format [N, Tmax].\n        size (int): Size of window.\n        k (int, optional): Standard value k = 1.\n\n    Returns:\n        double: Correlation of correlation matrix for all timepoints [timepoints/size, timepoints/size].\n\n    References\n    ----------\n\n    .. [1] \n    Hansen, E. C. A. et al. (2015) \u2018Functional connectivity dynamics: \n    Modeling the switching behavior of the resting state\u2019, NeuroImage. \n    105, pp. 525\u2013535. \n    doi: 10.1016/j.neuroimage.2014.11.001.\n\n    \"\"\"\n\n    edges_series, rss = dyn.get_edgests(series, size, k)\n    corrcorr = corrcoef(edges_series, rowvar = False)\n\n    return corrcorr\n</code></pre>"},{"location":"cofluct-reference/","title":"Cofluctuations","text":""},{"location":"cofluct-reference/#dynfc.cofluct.cofluct","title":"<code>cofluct(series, size, k=1)</code>","text":"<p>Run cofluctuation analysis for BOLD signal.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>double</code> <p>BOLD signal array for all parcels/voxels in the format [N, Tmax].</p> required <code>size</code> <code>int</code> <p>Size of window.</p> required <p>Returns:</p> Name Type Description <code>double</code> <p>Cofluctuation matrix for all parcels/voxels in the format [N, N, Tmax].</p>"},{"location":"cofluct-reference/#dynfc.cofluct.cofluct--references","title":"References","text":"<p>.. [1]  Esfahlani, F. Z. et al. (2020) \u2018High-amplitude cofluctuations in cortical activity drive  functional connectivity\u2019, Proceedings of the National Academy of Sciences of the United  States of America, 117(45), pp. 28393\u201328401. doi: 10.1073/pnas.2005531117.</p> <p>.. [2] Faskowitz, J. et al. (2020) \u2018Edge-centric functional network representations of human  cerebral cortex reveal overlapping system-level architecture\u2019, Nature Neuroscience.  Springer US, 23(12), pp. 1644\u20131654. doi: 10.1038/s41593-020-00719-y.</p> Source code in <code>dynfc/cofluct.py</code> <pre><code>def cofluct(series, size, k=1):\n\"\"\"Run cofluctuation analysis for BOLD signal.\n\n    Args:\n        series (double): BOLD signal array for all parcels/voxels in the format [N, Tmax].\n        size (int): Size of window.\n\n    Returns:\n        double: Cofluctuation matrix for all parcels/voxels in the format [N, N, Tmax].\n\n    References\n    ----------\n\n    .. [1] \n    Esfahlani, F. Z. et al. (2020) \u2018High-amplitude cofluctuations in cortical activity drive \n    functional connectivity\u2019, Proceedings of the National Academy of Sciences of the United \n    States of America, 117(45), pp. 28393\u201328401. doi: 10.1073/pnas.2005531117.\n\n    .. [2]\n    Faskowitz, J. et al. (2020) \u2018Edge-centric functional network representations of human \n    cerebral cortex reveal overlapping system-level architecture\u2019, Nature Neuroscience. \n    Springer US, 23(12), pp. 1644\u20131654. doi: 10.1038/s41593-020-00719-y.\n\n    \"\"\"\n    corr_mats, idx = dyn.corr_slide(series, size)\n    edges_series = zeros((len(triu_indices(corr_mats.shape[0], k)[0]),\n    corr_mats.shape[2]))\n\n    ts_z = zscore(series, axis=1, ddof=1)\n    upt = np.triu_indices(ts_z.shape[0], k)\n\n    edges_series = multiply(ts_z[upt[0], ], ts_z[upt[1], ])\n\n    rss = sqrt(np.sum(square(edges_series), axis=0))\n\n    return edges_series, corr_mats, rss\n</code></pre>"},{"location":"corr_slide-reference/","title":"Sliding windows correlations","text":""},{"location":"corr_slide-reference/#dynfc.corr_slide.corr_slide","title":"<code>corr_slide(series, size, slide=None)</code>","text":"<p>Run cofluctuation analysis for BOLD signal.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>double</code> <p>BOLD signal array for all parcels/voxels in the format [N, Tmax].</p> required <code>size</code> <code>int</code> <p>Size of sliding window.</p> required <code>slide</code> <code>int</code> <p>Shift between windows. The standard value is the window size. Non-overlapping.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>double</code> <p>Cofluctuation matrix for all parcels/voxels in the format [N, N, window].</p>"},{"location":"corr_slide-reference/#dynfc.corr_slide.corr_slide--references","title":"References","text":"<p>.. [1]  Hansen, E. C. A. et al. (2015) \u2018Functional connectivity dynamics: Modeling the switching  behavior of the resting state\u2019, NeuroImage. The Authors, 105, pp. 525\u2013535.  doi: 10.1016/j.neuroimage.2014.11.001.</p> Source code in <code>dynfc/corr_slide.py</code> <pre><code>def corr_slide(series, size, slide = None):\n\"\"\"Run cofluctuation analysis for BOLD signal.\n\n    Args:\n        series (double): BOLD signal array for all parcels/voxels in the format [N, Tmax].\n        size (int): Size of sliding window.\n        slide (int, optional): Shift between windows. The standard value is the window size.\n            Non-overlapping.\n\n    Returns:\n        double: Cofluctuation matrix for all parcels/voxels in the format [N, N, window].\n\n    References\n    ----------\n\n    .. [1] \n    Hansen, E. C. A. et al. (2015) \u2018Functional connectivity dynamics: Modeling the switching \n    behavior of the resting state\u2019, NeuroImage. The Authors, 105, pp. 525\u2013535. \n    doi: 10.1016/j.neuroimage.2014.11.001.\n\n\n    \"\"\"\n    if slide == None:\n        slide = size\n\n    idx = arange(0, series.shape[1], slide)\n    corr_mats = zeros((series.shape[0], series.shape[0], idx.shape[0]))\n\n    for w in range(idx.shape[0]):\n        corr_mats[:, :, w] = corrcoef(series[:, 0 + idx[w]: size + idx[w]])\n\n    return corr_mats, idx\n</code></pre>"},{"location":"dPL-reference/","title":"Synamic Phase-Locking","text":""},{"location":"dPL-reference/#dynfc.dPL.dPL","title":"<code>dPL(N, Tmax, phases)</code>","text":"<p>Dynamic Phase-Locking.</p> <p>This fuction returns the dynamic Phase-Locking for all parcels/voxels of the input.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Number of parcels/voxels of the input array.</p> required <code>Tmax</code> <code>int</code> <p>BOLD signal samples count.</p> required <code>phases</code> <code>ndarray</code> <p>Phases signal array for all parcels/voxels in the format [N, Tmax].</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>syncConnAux : Synchronicity matrix for all parcels/voxels in the format [N, N],  leidaArrayAux : Leading eigenvector of synchornicity matrix [Tmax, N].</p>"},{"location":"dPL-reference/#dynfc.dPL.dPL--references","title":"References","text":"<p>.. [1]  Cabral, J. et al. (2017). \u2018Cognitive performance in healthy  older adults relates to spontaneous switching between states  of functional connectivity during rest\u2019, Scientific Reports.  Nature Publishing Group, 7(1), p. 5135.  doi: 10.1038/s41598-017-05425-7.</p> <p>.. [2]  Lord et al,. (2019). Dynamical exploration of the  repertoire of brain networks at rest is  modulated by psilocybin. NeuroImage, 199(April), 127\u2013142.  https://doi.org/10.1016/j.neuroimage.2019.05.060</p> Source code in <code>dynfc/dPL.py</code> <pre><code>def dPL(N, Tmax, phases):\n\"\"\"Dynamic Phase-Locking.\n\n    This fuction returns the dynamic Phase-Locking for all parcels/voxels\n    of the input.\n\n    Args:\n        N (int): Number of parcels/voxels of the input array.\n        Tmax (int): BOLD signal samples count.\n        phases (ndarray): Phases signal array for all parcels/voxels in the format [N, Tmax].\n\n    Returns:\n        tuple: \n            syncConnAux : Synchronicity matrix for all parcels/voxels in the format [N, N], \n            leidaArrayAux : Leading eigenvector of synchornicity matrix [Tmax, N].\n\n    References\n    ----------\n\n    .. [1] \n    Cabral, J. et al. (2017). \u2018Cognitive performance in healthy \n    older adults relates to spontaneous switching between states \n    of functional connectivity during rest\u2019, Scientific Reports. \n    Nature Publishing Group, 7(1), p. 5135. \n    doi: 10.1038/s41598-017-05425-7.\n\n    .. [2] \n    Lord et al,. (2019). Dynamical exploration of the \n    repertoire of brain networks at rest is \n    modulated by psilocybin. NeuroImage, 199(April), 127\u2013142. \n    https://doi.org/10.1016/j.neuroimage.2019.05.060\n\n    \"\"\"\n\n    T = arange(10, Tmax - 10)\n\n    syncConnAux = zeros([N, N, Tmax-20])\n    syncAux = zeros([len(T), 1])\n\n    for t in range(0, len(T)):\n\n        for j in range(0, N):\n\n            for k in range(0, j + 1):\n\n                syncConnAux[j, k, t] = phDiff(phases[j, T[t]],\n                                                       phases[k, T[t]])\n                syncConnAux[k, j, t] = syncConnAux[j, k, t]\n\n    leidaArrayAux = get_LEiDA(syncConnAux)\n\n    return syncConnAux, leidaArrayAux\n</code></pre>"},{"location":"doEuclid-reference/","title":"Euclidean distance","text":""},{"location":"doEuclid-reference/#dynfc.doEuclid.doEuclid","title":"<code>doEuclid(PCs)</code>","text":"<p>Obtain Euclidean distance to the previous points.</p> <p>Parameters:</p> Name Type Description Default <code>PCs</code> <code>ndarray</code> <p>PCs array in the format [Subs * Tmax, n PCs].</p> required <p>Returns:</p> Name Type Description <code>double</code> <p>Euclidean distances in the format [1, Subs * Tmax].</p> Source code in <code>dynfc/doEuclid.py</code> <pre><code>def doEuclid(PCs):\n\"\"\"Obtain Euclidean distance to the previous points.\n\n    Args:\n        PCs (ndarray): PCs array in the format [Subs * Tmax, n PCs].\n\n    Returns:\n        double : Euclidean distances in the format [1, Subs * Tmax].\n\n    \"\"\"\n\n    d = zeros(PCs.shape[0])\n\n    for i in range(1, PCs.shape[0]):\n\n        d[i] = distance.euclidean(PCs[i - 1, ], PCs[i, ])\n\n    return d\n</code></pre>"},{"location":"doHilbert-reference/","title":"Hilbert transform","text":""},{"location":"doHilbert-reference/#dynfc.doHilbert.doHilbert","title":"<code>doHilbert(N, Tmax, timeseries)</code>","text":"<p>Hilbert transform of BOLD signal form all parcels/voxels.</p> <p>This fuction returns the phase time series for all parcels/voxels of the input.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Number of parcels/voxels of the input array.</p> required <code>Tmax</code> <code>int</code> <p>BOLD signal samples count.</p> required <code>timeseries</code> <code>double</code> <p>Bold signal array for all parcels/voxels in the format [N, Tmax].</p> required <p>Returns:</p> Name Type Description <code>PhasesAux</code> <p>Phases array for all parcels/voxels in the format [N, Tmax].</p> Source code in <code>dynfc/doHilbert.py</code> <pre><code>def doHilbert(N, Tmax, timeseries):\n\"\"\"Hilbert transform of BOLD signal form all parcels/voxels.\n\n    This fuction returns the phase time series for all parcels/voxels\n    of the input.\n\n    Args:\n        N (int): Number of parcels/voxels of the input array.\n        Tmax (int): BOLD signal samples count.\n        timeseries (double): Bold signal array for all parcels/voxels in the format [N, Tmax].\n\n    Returns:\n        PhasesAux : Phases array for all parcels/voxels in the format [N, Tmax].\n\n    \"\"\"\n\n    PhasesAux = zeros([N, Tmax])\n\n    for seed in range(0, N):\n        Xanalytic = hilbert(timeseries[seed, :] - timeseries[seed, :].mean())\n        PhasesAux[seed, :] = angle(Xanalytic)\n\n\n    return PhasesAux\n</code></pre>"},{"location":"doKuramoto-reference/","title":"Kuramoto Order Parameter","text":""},{"location":"doKuramoto-reference/#dynfc.doKuramoto.doKuramoto","title":"<code>doKuramoto(N, Tmax, phases, base=2, nBits=8)</code>","text":"<p>Dynamic Phase-Locking.</p> <p>This fuction returns the dynamic Phase-Locking for all parcels/voxels of the input.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Number of parcels/voxels of the input array.</p> required <code>Tmax</code> <code>int</code> <p>BOLD signal samples count.</p> required <code>phases</code> <code>ndarray</code> <p>Phases signal array for all parcels/voxels in the format [N, Tmax].</p> required <code>base</code> <code>double</code> <p>Base for obtaining Shannon entropy.</p> <code>2</code> <code>nBits</code> <code>int</code> <p>n</p> <code>8</code> Return <p>tuple:     syncAux : Synchronicity matrix for all parcels/voxels in the format [N, N],      metastabAux : Metastability index - Standard deviation of Kuramoto Parameter</p>"},{"location":"doKuramoto-reference/#dynfc.doKuramoto.doKuramoto--references","title":"References","text":"<p>.. [1]</p> Source code in <code>dynfc/doKuramoto.py</code> <pre><code>def doKuramoto(N, Tmax, phases, base = 2, nBits = 8):\n\"\"\"Dynamic Phase-Locking.\n\n    This fuction returns the dynamic Phase-Locking for all parcels/voxels\n    of the input.\n\n    Args:\n        N (int): Number of parcels/voxels of the input array.\n        Tmax (int): BOLD signal samples count.\n        phases (ndarray): Phases signal array for all parcels/voxels in the format [N, Tmax].\n        base (double, optional): Base for obtaining Shannon entropy.\n        nBits (int, optional): n\n\n    Return:\n        tuple:\n            syncAux : Synchronicity matrix for all parcels/voxels in the format [N, N], \n            metastabAux : Metastability index - Standard deviation of Kuramoto Parameter\n\n    References\n    ----------\n\n    .. [1] \n\n\n    \"\"\"\n\n    T = arange(10, Tmax - 10)\n\n    syncAux = zeros([len(T), 1])\n\n    for t in range(0, len(T)):\n\n        ku = sum(cos(phases[:, T[t]]) + 1j * sin(phases[:, T[t]])) / N\n        syncAux[t] = abs(ku)\n\n    metastabAux = std(syncAux)\n    shEntropy = getEntropy(syncAux[:,0], base, nBits)\n\n    return metastabAux, syncAux, shEntropy\n</code></pre>"},{"location":"getEntropy-reference/","title":"Shannon Entropy","text":""},{"location":"getEntropy-reference/#dynfc.getEntropy.getEntropy","title":"<code>getEntropy(series, base=2, nBits=None)</code>","text":"<p>Obtain Shannon Entropy estimate from a vector values/time series.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>ndarray</code> <p>Phases signal array for all parcels/voxels in the format [N, Tmax].</p> required <code>base</code> <code>double</code> <p>Base of logarithm for Shannon entropy expression. Standard value is 2.</p> <code>2</code> Return <p>double: Shannon entropy.</p>"},{"location":"getEntropy-reference/#dynfc.getEntropy.getEntropy--references","title":"References","text":"<p>.. [1]</p> Source code in <code>dynfc/getEntropy.py</code> <pre><code>def getEntropy(series, base = 2, nBits = None):\n\"\"\"Obtain Shannon Entropy estimate from a vector values/time series.\n\n    Args:\n        series (ndarray): Phases signal array for all parcels/voxels in the format [N, Tmax].\n        base (double, optional): Base of logarithm for Shannon entropy expression. Standard value is 2.\n\n    Return:\n        double: Shannon entropy.\n\n    References\n    ----------\n\n    .. [1] \n\n\n    \"\"\"\n\n    if nBits != None:\n        series = round_(multiply(series, 2 ** nBits))\n\n    mags, probs = unique(series, \n                         return_counts=True)\n    entr = entropy(probs, base=base)\n\n    return entr\n</code></pre>"},{"location":"get_LEiDA-reference/","title":"LEiDA vector","text":""},{"location":"get_LEiDA-reference/#dynfc.get_LEiDA.get_LEiDA","title":"<code>get_LEiDA(syncConnAux)</code>","text":"<p>Obtain leading eigenvector for synchronicity matrices.</p> <p>Parameters:</p> Name Type Description Default <code>syncConnAux</code> <code>ndarray</code> <p>Synchronicty matrices for all parcels/voxels in the format [N, N, Tmax].</p> required <p>Returns:</p> Name Type Description <code>leidaArrayAux</code> <p>Leading eigenvector of synchornicity matrix [Tmax, N].</p>"},{"location":"get_LEiDA-reference/#dynfc.get_LEiDA.get_LEiDA--references","title":"References","text":"<p>.. [1]  Cabral, J. et al. (2017). \u2018Cognitive performance in healthy  older adults relates to spontaneous switching between states  of functional connectivity during rest\u2019, Scientific Reports.  Nature Publishing Group, 7(1), p. 5135.  doi: 10.1038/s41598-017-05425-7.</p> <p>.. [2]  Lord et al,. (2019). Dynamical exploration of the  repertoire of brain networks at rest is  modulated by psilocybin. NeuroImage, 199(April), 127\u2013142.  https://doi.org/10.1016/j.neuroimage.2019.05.060</p> Source code in <code>dynfc/get_LEiDA.py</code> <pre><code>def get_LEiDA(syncConnAux):\n\"\"\"Obtain leading eigenvector for synchronicity matrices.\n\n    Args:\n        syncConnAux (ndarray): Synchronicty matrices for all parcels/voxels in the format [N, N, Tmax].\n\n    Returns:\n        leidaArrayAux : Leading eigenvector of synchornicity matrix [Tmax, N].\n\n    References\n    ----------\n\n    .. [1] \n    Cabral, J. et al. (2017). \u2018Cognitive performance in healthy \n    older adults relates to spontaneous switching between states \n    of functional connectivity during rest\u2019, Scientific Reports. \n    Nature Publishing Group, 7(1), p. 5135. \n    doi: 10.1038/s41598-017-05425-7.\n\n    .. [2] \n    Lord et al,. (2019). Dynamical exploration of the \n    repertoire of brain networks at rest is \n    modulated by psilocybin. NeuroImage, 199(April), 127\u2013142. \n    https://doi.org/10.1016/j.neuroimage.2019.05.060\n\n    \"\"\"\n\n    tPoints = syncConnAux.shape[2]\n\n    leidaArrayAux = zeros([tPoints,  syncConnAux.shape[0]])\n\n    for i in range(tPoints):\n\n        matrix = syncConnAux[:, :, i]\n        D, V = eigh(matrix)\n        V1 = V[:, -1]\n\n        if sum(V1) &gt; 0:\n            V1 = -V1\n\n        leidaArrayAux[i, :] = V1\n\n    return leidaArrayAux\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>The easiest way to install dynfc is via pip (PyPI) with the command below.</p> <pre><code>pip install dynfc\n</code></pre> <p>If you would like to specify a version use the following command to install version 0.0.1a1, for example.</p> <pre><code>pip install dynfc==0.0.1a1\n</code></pre> <p>Alternatively one can clone this repository and add it to a project. For that use the following command.</p> <pre><code>https://github.com/CoDe-Neuro/\n</code></pre>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2021 Lucas G. S. Fran\u00e7a and Dafnis Batall\u00e9</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"phDiff-reference/","title":"Phase lock","text":""},{"location":"phDiff-reference/#dynfc.phDiff.phDiff","title":"<code>phDiff(a, b)</code>","text":"<p>Cosine of phase difference.</p> <p>This function estimates the phase difference of the two entries and its cosine.</p> \\[PL = \\cos{(a - b)}\\] <p>Parameters:</p> Name Type Description Default <code>a</code> <code>double</code> <p>Phase 1 in \\(\\pi\\) rad.</p> required <code>b</code> <code>double</code> <p>Phase 2 in \\(\\pi\\) rad.</p> required <p>Returns:</p> Name Type Description <code>double</code> <p>Cosine of phase difference.</p> Example <p>import numpy as np a = np.pi b = - np.pi print(phDiff(a,b)) 1.0</p>"},{"location":"phDiff-reference/#dynfc.phDiff.phDiff--references","title":"References","text":"<p>.. [1]  Lord et al,. (2019). Dynamical exploration of the  repertoire of brain networks at rest is  modulated by psilocybin. NeuroImage, 199(April), 127\u2013142.  https://doi.org/10.1016/j.neuroimage.2019.05.060</p> Source code in <code>dynfc/phDiff.py</code> <pre><code>def phDiff(a, b):\n\"\"\"Cosine of phase difference.\n\n    This function estimates the phase difference of the two entries and its cosine.\n\n    $$PL = \\cos{(a - b)}$$\n\n    Args:\n        a (double): Phase 1 in $\\pi$ rad.\n        b (double): Phase 2 in $\\pi$ rad.\n\n    Returns:\n        double: Cosine of phase difference.\n\n    Example:\n            &gt;&gt;&gt; import numpy as np\n            &gt;&gt;&gt; a = np.pi\n            &gt;&gt;&gt; b = - np.pi\n            &gt;&gt;&gt; print(phDiff(a,b))\n            1.0\n\n    References\n    ----------\n\n    .. [1] \n    Lord et al,. (2019). Dynamical exploration of the \n    repertoire of brain networks at rest is \n    modulated by psilocybin. NeuroImage, 199(April), 127\u2013142. \n    https://doi.org/10.1016/j.neuroimage.2019.05.060\n\n    \"\"\"\n\n    c = cos(a - b)\n    return c\n</code></pre>"},{"location":"run_multiPatKOP-reference/","title":"KOP","text":""},{"location":"run_multiPatKOP-reference/#dynfc.run_multiPatKOP.run_multiPatKOP","title":"<code>run_multiPatKOP(RSsig, base=2, nBits=8, delt=0.392, flp=0.04, fhi=0.07, k=2)</code>","text":"<p>Run KOP Routine for BOLD signal.</p> <p>Parameters:</p> Name Type Description Default <code>RSsig</code> <code>ndarray</code> <p>BOLD signal array for all parcels/voxels in the format [N, Tmax, Subs].</p> required <code>delt</code> <p>TR sample.</p> <code>0.392</code> <code>flp</code> <p>low threshold frequency of filter</p> <code>0.04</code> <code>fhi</code> <p>high threshold frequency of filter</p> <code>0.07</code> <code>k</code> <p>filter order</p> <code>2</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>phases : Phases array for all parcels/voxels in the format [N, Tmax, Subs]. sync : Synchronicity matrix for all parcels/voxels in the format [Tmax, Subs]. metastab : Leading eigenvector of synchornicity matrix [Subs].</p>"},{"location":"run_multiPatKOP-reference/#dynfc.run_multiPatKOP.run_multiPatKOP--references","title":"References","text":"<p>.. [1]</p> Source code in <code>dynfc/run_multiPatKOP.py</code> <pre><code>def run_multiPatKOP(RSsig, base=2, nBits=8, delt = 0.392, flp=.04, fhi=.07, k=2):\n\"\"\"Run KOP Routine for BOLD signal.\n\n    Args:\n        RSsig (ndarray): BOLD signal array for all parcels/voxels in the format [N, Tmax, Subs].\n        delt: TR sample.\n        flp: low threshold frequency of filter\n        fhi: high threshold frequency of filter\n        k: filter order\n\n    Returns:\n        tuple:\n            phases : Phases array for all parcels/voxels in the format [N, Tmax, Subs].\n            sync : Synchronicity matrix for all parcels/voxels in the format [Tmax, Subs].\n            metastab : Leading eigenvector of synchornicity matrix [Subs].\n\n\n    References\n    ----------\n\n    .. [1] \n\n\n    \"\"\"\n\n    Tmax = RSsig.shape[0]\n    N = RSsig.shape[1]\n    nSub = RSsig.shape[2]\n\n    metastab = zeros([nSub])\n    shEntropy = zeros([nSub])\n    phases = zeros([N, Tmax, nSub])\n    sync = zeros([Tmax - 20, nSub])\n\n    #flp = .04              # lowpass frequency of filter\n    #fhi = .07              # highpass\n    npts = Tmax            # total nb of points\n    #delt = 2               # sampling interval\n    #k = 2                  # 2nd order butterworth filter\n\n    for pat in range(nSub):\n\n        timeserie = zeros([N, Tmax])\n        signal = RSsig[:, :, pat].transpose()\n\n        for seed in range(N):\n            timeserie[seed, :] = butter_bandpass_filter(signal[seed, :],\n                                                        flp, fhi, delt, k)\n        print('Signal filtered.')\n        phases[:, :, pat] = doHilbert(N, Tmax, timeserie)\n\n        print('Phases obtained.')\n        metastabAux, syncAux, shEntropyAux = doKuramoto(\n            N, Tmax, phases[:, :, pat], base, nBits)\n        sync[:, pat] = syncAux[:,0]\n        metastab[pat] = metastabAux\n        shEntropy[pat] = shEntropyAux\n\n        print('Matrices obtained.')\n        print('Routine finished for patient no. ' + str(pat + 1) + '.')\n\n    return metastab, sync, shEntropy\n</code></pre>"},{"location":"run_multiPatLEiDA-reference/","title":"KOP LEiDA","text":""},{"location":"run_multiPatLEiDA-reference/#dynfc.run_multiPatLEiDA.run_multiPatLEiDA","title":"<code>run_multiPatLEiDA(RSsig, delt, flp, fhi, k)</code>","text":"<p>Run LEiDA Routine for BOLD signal.</p> <p>Parameters:</p> Name Type Description Default <code>RSsig</code> <code>ndarray</code> <p>BOLD signal array for all parcels/voxels in the format [N, Tmax, Subs].</p> required <code>delt</code> <p>TR sample.</p> required <code>flp</code> <p>low threshold frequency of filter</p> required <code>fhi</code> <p>high threshold frequency of filter</p> required <code>k</code> <p>filter order</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>phase: Phases array for all parcels/voxels in the format, syncConn: Synchronicity matrix for all parcels/voxels in the format, leidaArray: Leading eigenvector of synchornicity matrix</p>"},{"location":"run_multiPatLEiDA-reference/#dynfc.run_multiPatLEiDA.run_multiPatLEiDA--references","title":"References","text":"<p>.. [1] Cabral, J. et al. (2017) \u2018Cognitive performance in healthy older adults relates to spontaneous switching between states of functional connectivity during rest\u2019, Scientific Reports. Nature Publishing Group, 7(1), p. 5135. doi: 10.1038/s41598-017-05425-7.</p> <p>.. [2] Lord et al,. (2019). Dynamical exploration of the repertoire of brain networks at rest is modulated by psilocybin. NeuroImage, 199(April), 127\u2013142. https://doi.org/10.1016/j.neuroimage.2019.05.060</p> Source code in <code>dynfc/run_multiPatLEiDA.py</code> <pre><code>def run_multiPatLEiDA(RSsig, delt, flp, fhi, k):\n\"\"\"Run LEiDA Routine for BOLD signal.\n\n    Args:\n        RSsig (ndarray): BOLD signal array for all parcels/voxels in the format [N, Tmax, Subs].\n        delt: TR sample.\n        flp: low threshold frequency of filter\n        fhi: high threshold frequency of filter\n        k: filter order\n\n    Returns:\n        tuple:\n            phase: Phases array for all parcels/voxels in the format,\n            syncConn: Synchronicity matrix for all parcels/voxels in the format,\n            leidaArray: Leading eigenvector of synchornicity matrix\n\n    References\n    ----------\n\n    .. [1]\n    Cabral, J. et al. (2017) \u2018Cognitive performance in healthy\n    older adults relates to spontaneous switching between states\n    of functional connectivity during rest\u2019, Scientific Reports.\n    Nature Publishing Group, 7(1), p. 5135.\n    doi: 10.1038/s41598-017-05425-7.\n\n    .. [2]\n    Lord et al,. (2019). Dynamical exploration of the\n    repertoire of brain networks at rest is\n    modulated by psilocybin. NeuroImage, 199(April), 127\u2013142.\n    https://doi.org/10.1016/j.neuroimage.2019.05.060\n\n\n    \"\"\"\n\n    Tmax = RSsig.shape[0]\n    N = RSsig.shape[1]\n    nSub = RSsig.shape[2]\n\n    leidaArray = zeros([Tmax - 20, N, nSub])\n    syncConn = zeros([N, N, Tmax - 20, nSub])\n    phases = zeros([N, Tmax, nSub])\n\n    #flp = .04              # lowpass frequency of filter\n    #fhi = .07              # highpass\n    npts = Tmax            # total nb of points\n    #delt = 0.392               # sampling interval\n    #k = 2                  # 2nd order butterworth filter\n\n    for pat in range(nSub):\n\n        timeserie = zeros([N, Tmax])\n        signal = RSsig[:, :, pat].transpose()\n\n        for seed in range(N):\n            timeserie[seed, :] = butter_bandpass_filter(signal[seed, :],\n                                                    flp, fhi, delt, k)\n        print('Signal filtered.')\n        phases[:, :, pat] = doHilbert(N, Tmax, timeserie)\n\n        print('Phases obtained.')\n        syncConnAux, leidaArrayAux = dPL(N, Tmax, phases[:, :, pat])\n        syncConn[:, :, :, pat] = syncConnAux\n        leidaArray[:, :, pat] = leidaArrayAux\n\n        print('Matrices obtained.')\n        print('Routine finished for patient no. ' + str(pat + 1) + '.')\n\n    return phases, syncConn, leidaArray\n</code></pre>"}]}